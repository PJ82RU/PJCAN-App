# PJCAN App
Проект CANBUS адаптера для Mazda 

Группа в телеграм: https://t.me/pjcan

# API 4.1.0

### Bluetooth

* name `PJCAN`
* uuid server `cc9e7b30-9834-488f-b762-aa62f5022dd4`
* uuid characteristic `cc9e7b30-9834-488f-b762-aa62f5022dd4`



### Структура пакетов

* **Версия прошивки:**

  **запрос:**
  > uint8_t `id` = `0x00`
  >
  > uint16_t `size` = `0x00`

  **ответ:**

  > uint8_t `id` = `0x00`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > ```c++
  > struct {
  >     uint8_t major;
  >     uint8_t minor;
  >     uint8_t build;
  >     uint8_t revision;
  > }
  > ```



#### Устройство PJCAN

* **Информация об устройстве:**

  **запрос:**
  > uint8_t `id` = `0x01`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x01`
  >
  > uint16_t `size` = `0xaf`
  >
  > uint8_t  `data[175]` = [..]
  >
  > ```c++
  > struct {
  >     uint8_t chip_cores;                 // Количество ядер
  >     char chip_model[16];                // Модель чипа
  >     uint8_t chip_revision;              // Номер ревизии чипа
  >     uint32_t cpu_freq_mhz;              // Частота ЦП, МГц
  >     uint32_t cycle_count;               // Количество циклов
  >     uint64_t efuse_mac;                 // MAC-адрес
  >     uint8_t flash_chip_mode;            // Режим флеш-памяти
  >     uint32_t flash_chip_size;           // Размер флеш-памяти, байт
  >     uint32_t flash_chip_speed;          // Частота флеш-памяти
  >     uint32_t free_heap;                 // Свободной кучи в памяти
  >     uint32_t free_psram;                // Свободной SPI RAM
  >     uint32_t free_sketch_space;         // Свободное место для прошивки
  >     uint32_t heap_size;                 // Размер кучи в памяти
  >     uint32_t max_alloc_heap;            // Размер самого большого блока кучи
  >     uint32_t max_alloc_psram;           // Размер самого большого блока SPI RAM
  >     uint32_t min_free_heap;             // Наименьший уровень свободной кучи
  >     uint32_t min_free_psram;            // Наименьший уровень свободной SPI RAM
  >     uint32_t psram_size;                // Размер SPI RAM
  >     char sdk_version[8];                // Версия SDK
  >     char sketch_md5[16];                // MD5 прошивки
  >     uint32_t sketch_size;               // Размер прошивки
  >     uint32_t temperature_chip;          // Температура чипа (n/100)
  >     uint8_t sha[32];                    // Хеш устройства
  >     char hardware[32];                  // Версия платы
  > }
  > ```

* **Активация устройства:**

  **запрос:**
  > uint8_t `id` = `0x02`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x02`
  >
  > uint16_t `size` = `0x40`
  >
  > uint8_t  `data[64]` = [..]
  >
  > ```c++
  > struct {
  >     char serial[64];        // Серийный номер
  > }
  > ```

* **Параметры устройства:**

  **запрос:**
  > uint8_t `id` = `0x08`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     bool disable_led_work: 1;           // Выключить управление контакта LED_WORK
  >     bool disable_reverse: 1;            // Выключить управление контакта REVERSE
  >     bool disable_r_position: 1;         // Выключить управление контакта R_POSITION
  >     bool disable_amp_illum: 1;          // Выключить управление контакта AMP_ILLUM
  >     bool disable_voltmeter: 1;          // Выключить вольтметр
  >     bool nop: 3;
  >     int8_t calibration_of_voltmeter;    // Калибровка вольтметра
  > }
  > ```
  >

  **ответ:**
  > uint8_t `id` = `0x08`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     bool disable_led_work: 1;           // Выключить управление контакта LED_WORK
  >     bool disable_reverse: 1;            // Выключить управление контакта REVERSE
  >     bool disable_r_position: 1;         // Выключить управление контакта R_POSITION
  >     bool disable_amp_illum: 1;          // Выключить управление контакта AMP_ILLUM
  >     bool disable_voltmeter: 1;          // Выключить вольтметр
  >     bool nop: 3;
  >     int8_t calibration_of_voltmeter;    // Калибровка вольтметра
  > }
  > ```

* **Значения устройства:**

  **запрос:**
  > uint8_t `id` = `0x03`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x03`
  >
  > uint16_t `size` = `0x0c`
  >
  > uint8_t  `data[12]` = [..]
  >
  > ```c++
  > struct {
  >     bool activation;            // Статус активации
  >     bool state_led_work;        // Текущее состояние контакта LED_WORK
  >     bool state_reverse;         // Текущее состояние контакта REVERSE
  >     bool state_r_position;      // Текущее состояние контакта R_POSITION
  >     bool state_amp_illum;       // Текущее состояние контакта AMP_ILLUM
  >     bool config_save;           // Статус сохранения конфигурации
  >     struct {
  >          uint8_t major;
  >          uint8_t minor;
  >          uint8_t build;
  >          uint8_t revision;
  >     } hardware;                 // Версия платы
  >     uint8_t led;                // Состояние мигания светодиода
  >     uint16_t voltmeter;         // Значение вольтметра (n/100)
  >     uint32_t worktime;          // Время работы устройства, сек
  > }
  > ```

  `led`:

  > `0x00` Светодиод не горит
  >
  > `0x01` Светодиод горит
  >
  > `0x02` Светодиод мигает с указанным интервалом
  >
  > `0x03` Двойное мигание светодиодом, с указанным интервалом
  >
  > `0x04` Тройное мигание светодиодом, с указанным интервалом

* **Действия с устройством:**

  **запрос:**
  > uint8_t `id` = `0x04`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > ```c++
  > struct {
  >     bool reboot;            // Перезагрузка устройства
  >     bool reset_config;      // Сбросить конфигурацию
  >     bool reset_view;        // Сбросить конфигурацию отображения
  >     bool reset_buttons;     // Сбросить конфигурацию кнопок 
  >     bool save;              // Сохранить данные принудительно
  >     bool format;            // Форматирование SPIFFS с сохранением параметров
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x04`
  >
  > uint16_t `size` = `0x00`

* **Обновление прошивки устройства:**

  **запрос:**
  > uint8_t `id` = `0x05`
  >
  > uint16_t `size` = `0x1f7`
  >
  > uint8_t  `data[503]` = [..]
  >
  > ```c++
  > struct {
  >     bool begin;             // Начало прошивки
  >     bool end;               // Завершение прошивки и перезагрузка
  >     bool abort;             // Отмена прошивки
  >     bool encrypt;           // Зашифрованные данные
  >     bool iv;                // Данные IV
  >     uint32_t total;         // Размер прошивки
  >     uint16_t size;          // Размер данных
  >     uint8_t data[496];      // Данные прошивки
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x05`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > >`0x00` ОК
  > >
  > >`0x01` Нет данных
  > >
  > >`0x02` Нет данных для начала прошивки
  > >
  > >`0x03` Ошибка начала прошивки
  > >
  > >`0x04` Ошибка записи прошивки
  > >
  > >`0x05` Ошибка прошивки
  > >
  > >`0x06` Нет значения IV
  > >
  > >`0x07` Неверный ключ шифрования
  > >
  > >`0x08` Ошибка дешифровки прошивки
  > >
  > >`0x09` Остановка обновления по таймауту

* **Значения сканирования can-шины:**

  **запрос:**
  > uint8_t `id` = `0x06`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x06`
  >
  > uint16_t `size` = `0x151`
  >
  > uint8_t  `data[337]` = [..]
  >
  > ```c++
  > struct {
  >     uint8_t count;              // Количество кадров
  >     struct {
  >         uint32_t id;            // Идентификатор
  >         uint8_t data[8];        // Данные
  >         uint8_t length;         // Размер данных
  >         uint64_t timestamp;     // Временная метка
  >     } frames[16];               // Массив кадров
  > }
  > ```

* **Действия сканера can-шины:**

  **запрос:**
  > uint8_t `id` = `0x07`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     bool enabled;       // Включить сканирование
  >     uint8_t timeout;    // Таймаут выключения сканирования при бездействии, сек
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x07`
  >
  > uint16_t `size` = `0x00`



#### Кнопки SW1

* **Параметры кнопок:**

  **запрос:**
  > uint8_t `id` = `0x30`
  >
  > uint16_t `size` = `0x49`
  >
  > uint8_t  `data[73]` = [..]
  >
  > ```c++
  > struct {
  >     uint8_t hold;                   // Время удержания кнопки, сек.
  >     struct {
  >         bool extended;              // Расширенный функционал кнопок (двойное, тройное нажатие)
  >         bool swtch;                 // Переключатель
  >         uint8_t id;                 // ID кнопки (0 - кнопка не определена)
  >         uint16_t resistance_to;     // Сопротивление кнопки до
  >         uint8_t exec[4];            // Список ID функций кнопки
  >         uint8_t exec_mode[4];       // Список ID функций кнопки в режиме mode
  >     } buttons[6];                   // Параметры кнопок
  > }
  > ```
  >

  **ответ:**
  > uint8_t `id` = `0x30`
  >
  > uint16_t `size` = `0x49`
  >
  > uint8_t  `data[73]` = [..]
  >
  > ```c++
  > struct {
  >     uint8_t hold;                   // Время удержания кнопки, сек.
  >     struct {
  >         bool extended;              // Расширенный функционал кнопок (двойное, тройное нажатие)
  >         bool swtch;                 // Переключатель
  >         uint8_t id;                 // ID кнопки (0 - кнопка не определена)
  >         uint16_t resistance_to;     // Сопротивление кнопки до
  >         uint8_t exec[4];            // Список ID функций кнопки
  >         uint8_t exec_mode[4];       // Список ID функций кнопки в режиме mode
  >     } buttons[6];                   // Параметры кнопок
  > }
  > ```
  >

  **список ID функций кнопки:**:
  > `exec[0]` или `exec_mode[0]` Кнопка нажата один раз
  >
  > `exec[1]` или `exec_mode[1]` Кнопка нажата два раза
  >
  > `exec[2]` или `exec_mode[2]` Кнопка нажата три раза
  >
  > `exec[3]` или `exec_mode[3]` Удержание кнопки
  >
  > значение `exec[..]` или `exec_mode[..]`:
  >
  > >`0x00` Функция отсутствует
  > >
  > >`0x01` PJCAN: сменить режим управления
  > >
  > >`0x02` PJCAN: показать значения ДВС
  > >
  > >`0x03` PJCAN: показать значения расхода
  > >
  > >`0x04` PJCAN: показать значения движения
  > >
  > >`0x05` PJCAN: показать значения температуры
  > >
  > >`0x06` PJCAN: показать дату и время
  > >
  > >`0x07` ГУ: кнопка Mute на руле
  > >
  > >`0x08` ГУ: кнопка Mode на руле
  > >
  > >`0x09` ГУ: кнопка Set down на руле
  > >
  > >`0x0a` ГУ: кнопка Set up на руле
  > >
  > >`0x0b` ГУ: кнопка Vol+ на руле
  > >
  > >`0x0c` ГУ: кнопка Vol- на руле
  > >
  > >`0x0d` ГУ: открыть голосовое управление
  > >
  > >`0x0e` ГУ: открыть эквалайзер
  > >
  > >`0x0f` ГУ: открыть радио
  > >
  > >`0x10` ГУ: поиск волны радио
  > >
  > >`0x11` ГУ: открыть камеру
  > >
  > >`0x12` ГУ: открыть телефон
  > >
  > >`0x13` БК: кнопка Info (информация БК)
  > >
  > >`0x14` БК: кнопка Clock (время на БК)
  > >
  > >`0x15` БК: кнопка Clock H (часы)
  > >
  > >`0x16` БК: кнопка Clock M (минуты)
  > >
  > >`0x17` БК: кнопка Clock 24/12 (смена формата времени)
  > >
  > >`0x18` БК: кнопка сброса минут в 0
  > >
  > >`0x19` БК: сменить режим Info на Clock и обратно
  > >
  > >`0x1a` БК: нажатие и удержание кнопки Info (сброс расхода)
  > >
  > >`0x1b` БК: нажатие и удержание кнопки Clock (настройка часов)
  > >
  > >`0x1c` BOSE: вкл/выкл усилителя
  > >
  > >`0x1d` BOSE: вкл/выкл Audio PLT
  > >
  > >`0x1e` BOSE: mute
  > >
  > >`0x1f` BOSE: vol+
  > >
  > >`0x20` BOSE: vol-
  > >
  > >`0x21` BOSE: balance +
  > >
  > >`0x22` BOSE: balance -
  > >
  > >`0x23` BOSE: bass +
  > >
  > >`0x24` BOSE: bass -
  > >
  > >`0x25` BOSE: fade +
  > >
  > >`0x26` BOSE: fade -
  > >
  > >`0x27` BOSE: treble +
  > >
  > >`0x28` BOSE: treble -
  > >
  > >`0x29` BOSE: переключение режимов Center Point (циклично)


* **Значения нажатой кнопки:**

  **запрос:**
  > uint8_t `id` = `0x31`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x31`
  >
  > uint16_t `size` = `0x06`
  >
  > uint8_t  `data[6]` = [..]
  >
  > ```c++
  > struct {
  >     bool pressed;               // Кнопка нажата
  >     bool swtch;                 // Переключатель
  >     bool emulation;             // Эмуляция нажатия физической кнопки
  >     uint8_t id;                 // ID кнопки
  >     uint8_t type;               // Тип действия
  >     uint8_t exec;               // Функция к выполнению
  >     uint16_t resistance;        // Значение сопротивления кнопки
  > }
  > ```

  `type`:
  > `0x00` Обычное нажатие кнопки
  >
  > `0x01` Кнопка нажата два раза
  >
  > `0x02` Кнопка нажата три раза
  >
  > `0x03` Удержание кнопки

* **Действие с кнопками:**

  **запрос:**
  > uint8_t `id` = `0x32`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > ```c++
  > struct {
  >     bool default_mazda;         // Применить конфигурацию по умолчанию
  >     bool programming;           // Установить режим программирования кнопок
  >     bool exec_mode;             // Расширенный режим
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x32`
  >
  > uint16_t `size` = `0x00`



#### Кнопки SW3

* **Параметры кнопок:**

  **запрос:**
  > uint8_t `id` = `0x3a`
  >
  > uint16_t `size` = `0x1с`
  >
  > uint8_t  `data[28]` = [..]
  >
  > ```c++
  > struct {
  >     struct {
  >        uint8_t id;                  // ID кнопки (0 - кнопка не определена)
  >        uint16_t resistance_to;      // Сопротивление кнопки до
  >        uint8_t exec;                // ID функций кнопки
  >     } items[7];                     // Параметры кнопок
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x3a`
  >
  > uint16_t `size` = `0x1с`
  >
  > uint8_t  `data[28]` = [..]
  >
  > ```c++
  > struct {
  >     struct {
  >        uint8_t id;                  // ID кнопки (0 - кнопка не определена)
  >        uint16_t resistance_to;      // Сопротивление кнопки до
  >        uint8_t exec;                // ID функций кнопки
  >     } items[7];                     // Параметры кнопок
  > }
  > ```

  **список ID функций кнопки:**:
  > значение `exec[..]`:
  >
  > >`0x00` Функция отсутствует
  > >
  > >`0x01` PJCAN: сменить режим управления
  > >
  > >`0x02` PJCAN: показать значения ДВС
  > >
  > >`0x03` PJCAN: показать значения расхода
  > >
  > >`0x04` PJCAN: показать значения движения
  > >
  > >`0x05` PJCAN: показать значения температуры
  > >
  > >`0x06` PJCAN: показать дату и время
  > >
  > >`0x07` ГУ: кнопка Mute на руле
  > >
  > >`0x08` ГУ: кнопка Mode на руле
  > >
  > >`0x09` ГУ: кнопка Set down на руле
  > >
  > >`0x0a` ГУ: кнопка Set up на руле
  > >
  > >`0x0b` ГУ: кнопка Vol+ на руле
  > >
  > >`0x0c` ГУ: кнопка Vol- на руле
  > >
  > >`0x0d` ГУ: открыть голосовое управление
  > >
  > >`0x0e` ГУ: открыть эквалайзер
  > >
  > >`0x0f` ГУ: открыть радио
  > >
  > >`0x10` ГУ: поиск волны радио
  > >
  > >`0x11` ГУ: открыть камеру
  > >
  > >`0x12` ГУ: открыть телефон
  > >
  > >`0x13` БК: кнопка Info (информация БК)
  > >
  > >`0x14` БК: кнопка Clock (время на БК)
  > >
  > >`0x15` БК: кнопка Clock H (часы)
  > >
  > >`0x16` БК: кнопка Clock M (минуты)
  > >
  > >`0x17` БК: кнопка Clock 24/12 (смена формата времени)
  > >
  > >`0x18` БК: кнопка сброса минут в 0
  > >
  > >`0x19` БК: сменить режим Info на Clock и обратно
  > >
  > >`0x1a` БК: нажатие и удержание кнопки Info (сброс расхода)
  > >
  > >`0x1b` БК: нажатие и удержание кнопки Clock (настройка часов)
  > >
  > >`0x1c` BOSE: вкл/выкл усилителя
  > >
  > >`0x1d` BOSE: вкл/выкл Audio PLT
  > >
  > >`0x1e` BOSE: mute
  > >
  > >`0x1f` BOSE: vol+
  > >
  > >`0x20` BOSE: vol-
  > >
  > >`0x21` BOSE: balance +
  > >
  > >`0x22` BOSE: balance -
  > >
  > >`0x23` BOSE: bass +
  > >
  > >`0x24` BOSE: bass -
  > >
  > >`0x25` BOSE: fade +
  > >
  > >`0x26` BOSE: fade -
  > >
  > >`0x27` BOSE: treble +
  > >
  > >`0x28` BOSE: treble -
  > >
  > >`0x29` BOSE: переключение режимов Center Point (циклично)


* **Значения нажатой кнопки:**

  **запрос:**
  > uint8_t `id` = `0x3b`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x3b`
  >
  > uint16_t `size` = `0x06`
  >
  > uint8_t  `data[6]` = [..]
  >
  > ```c++
  > struct {
  >     bool pressed;               // Кнопка нажата
  >     bool swtch;                 // Переключатель
  >     bool emulation;             // Эмуляция нажатия физической кнопки
  >     uint8_t id;                 // ID кнопки
  >     uint8_t type;               // Тип действия
  >     uint8_t exec;               // Функция к выполнению
  >     uint16_t resistance;        // Значение сопротивления кнопки
  > }
  > ```

  `type`:
  > `0x00` Обычное нажатие кнопки
  >
  > `0x01` Кнопка нажата два раза
  >
  > `0x02` Кнопка нажата три раза
  >
  > `0x03` Удержание кнопки

  * **Действие с кнопками:**

    **запрос:**
  >   uint8_t `id` = `0x3c`
  >
  >   uint16_t `size` = `0x01`
  >
  >   uint8_t  `data[1]` = [..]
  >
  >   ```c++
  >   struct {
  >       bool reset;                 // Удалить все кнопки
  >       bool programming;           // Установить режим программирования кнопок
  >   }
  >   ```

  **ответ:**
  >   uint8_t `id` = `0x3c`
  >
  >   uint16_t `size` = `0x00`



#### Автомобиль

* **Параметры бортового компьютера:**

  **запрос:**
  > uint8_t `id` = `0x40`
  >
  > uint16_t `size` = `0x2e`
  >
  > uint8_t  `data[46]` = [..]
  >
  > ```c++
  > struct {
  >     bool lcd;               // Вкл/выкл вывод данных на LCD
  >     bool lcd_clock_24;      // 24-часовой формат времени на экране БК
  >     uint8_t car_model;      // Модель автомобиля
  >     char logo[12];          // Логотип
  >     char hello[32];         // Текст приветствия
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x40`
  >
  > uint16_t `size` = `0x2e`
  >
  > uint8_t  `data[46]` = [..]
  >
  > ```c++
  > struct {
  >     bool lcd;               // Вкл/выкл вывод данных на LCD
  >     bool lcd_clock_24;      // 24-часовой формат времени на экране БК
  >     uint8_t car_model;      // Модель автомобиля
  >     char logo[12];          // Логотип
  >     char hello[32];         // Текст приветствия
  > }
  > ```

  `car_model`:
  > `0x00` Автомобиль не определен
  >
  > `0x01` MAZDA 3 BK
  >
  > `0x02` MAZDA 3 BL
  >
  > `0x03` MAZDA 6 GG
  >
  > `0x04` MAZDA 6 GH
  >
  > `0x05` MAZDA CX7
  >
  > `0x06` MAZDA CX7 rest
  >
  > `0x07` MAZDA CX9
  >
  > `0x08` MAZDA CX9 rest
  >
  > `0x09` MAZDA 5

  * **Действия:**

    **запрос:**
  >   uint8_t `id` = `0x42`
  >
  >   uint16_t `size` = `0x02`
  >
  >   uint8_t  `data[2]` = [..]
  >
  >   ```c++
  >   struct {
  >       bool emulation;         // Эмуляция нажатия физической кнопки
  >       uint8_t exec;           // Функция к выполнению
  >   }
  >      ```

  **ответ:**
  >   uint8_t `id` = `0x42`
  >
  >   uint16_t `size` = `0x00`

* **Конфигурация отображения текста приветствия:**

  **запрос:**
  > uint8_t `id` = `0x43`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0x43`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



* **Дата и время:**

  **запрос:**
  > uint8_t `id` = `0x4a`
  >
  > uint16_t `size` = `0x06`
  >
  > uint8_t  `data[6]` = [..]
  >
  > ```c++
  > struct {
  >     bool show_date;                 // Показать дату
  >     bool show_time;                 // Показать время
  >     bool show_day_week;             // Показать день недели
  >     bool show_date_and_day_week;    // Показать дату и день недели
  >     bool show_time_and_day_week;    // Показать время и день недели
  >     bool show_full_datetime;        // Показать полную дату и время
  >     uint8_t timezone;               // Временная зона
  >     uint32_t unixtime;              // UnixTime
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x4a`
  >
  > uint16_t `size` = `0x06`
  >
  > uint8_t  `data[6]` = [..]
  >
  > ```c++
  > struct {
  >     bool show_date;                 // Показать дату
  >     bool show_time;                 // Показать время
  >     bool show_day_week;             // Показать день недели
  >     bool show_date_and_day_week;    // Показать дату и день недели
  >     bool show_time_and_day_week;    // Показать время и день недели
  >     bool show_full_datetime;        // Показать полную дату и время
  >     uint8_t timezone;               // Временная зона
  >     uint32_t unixtime;              // UnixTime
  > }
  > ```

* **Конфигурация отображения даты времени:**

  **запрос:**
  > uint8_t `id` = `0x4d`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0x4d`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Головное устройство (ГУ)

* **Параметры ГУ:**

  **запрос:**
  > uint8_t `id` = `0x50`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     bool show_text_of_logo;     // Отображать текст ГУ вместо логотипа
  >     bool send_button;           // Отправлять ГУ нажатие кнопок на руле
  >     bool send_climate;          // Отправлять ГУ значения климата
  >     bool send_doors;            // Отправлять ГУ статусы дверей автомобиля
  >     bool send_onboard;          // Отправлять ГУ статусы дверей и данные БК
  >     bool reverse_uart;          // Поменять местами контакты RX и TX
  >     bool hold_to_flip;          // Листать значение уровня громкости при удержании кнопки, если ГУ не поддерживает данный функционал
  >     uint8_t protocol;           // Протокол
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x50`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     bool show_text_of_logo;     // Отображать текст ГУ вместо логотипа
  >     bool send_button;           // Отправлять ГУ нажатие кнопок на руле
  >     bool send_climate;          // Отправлять ГУ значения климата
  >     bool send_doors;            // Отправлять ГУ статусы дверей автомобиля
  >     bool send_onboard;          // Отправлять ГУ статусы дверей и данные БК
  >     bool reverse_uart;          // Поменять местами контакты RX и TX
  >     bool hold_to_flip;          // Листать значение уровня громкости при удержании кнопки, если ГУ не поддерживает данный функционал
  >     uint8_t protocol;           // Протокол
  > }
  > ```

  `protocol`:

  > `0x00` PJCAN 4 UART
  >
  > `0x01` Raise HM_ND00
  >
  > `0x02` Raise HM_ND01
  >
  > `0x03` Raise HM_ND03
  >
  > `0x04` Simple Soft RP5_MZ_002

  * **Значения ГУ:**

    **запрос:**
  >   uint8_t `id` = `0x51`
  >
  >   uint16_t `size` = `0x00`

  **ответ:**
  >   uint8_t `id` = `0x51`
  >
  >   uint16_t `size` = `0x11`
  >
  >   uint8_t  `data[17]` = [..]
  >
  >   ```c++
  >   struct {
  >     struct {
  >         uint8_t hour;           // Час
  >         uint8_t minutes;        // Минуты
  >         uint8_t seconds;        // Секунды
  >     } clock;                    // Время ГУ
  >     uint8_t button;             // Кнопка ГУ (CLOCK, HOUR, MIN)
  >     char text[13];              // Тест ГУ
  >   }
  >   ```

* **Конфигурация отображения текста ГУ:**

  **запрос:**
  > uint8_t `id` = `0x53`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0x53`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Bose

* **Параметры Bose:**

  **запрос:**
  > uint8_t `id` = `0x60`
  >
  > uint16_t `size` = `0x08`
  >
  > uint8_t  `data[8]` = [..]
  >
  > ```c++
  > struct {
  >     bool on;                    // Вкл/выкл Bose
  >     bool audio_plt;             // Audio PLT
  >     bool radio_fm;              // Radio FM или AM
  >     bool wow;                   // Wow
  >     bool press;                 // Нажатие кнопки (для звука Wow)
  >     bool mute;                  // Выкл. звук
  >     bool start;                 // Изменять уровень звука при включении адаптера
  >     uint8_t volume;             // Уровень звука (от 0 до 63)
  >     uint8_t start_volume;       // Уровень звука при включении адаптера (от 0 до 63)
  >     int8_t balance;             // Баланс (от -8 до +8)
  >     int8_t bass;                // Бас (от -6 до +6)
  >     int8_t fade;                // Fade (от -8 до +8)
  >     int8_t treble;              // Treble (от -6 до +6)
  >     uint8_t center_point;       // Center point
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x60`
  >
  > uint16_t `size` = `0x08`
  >
  > uint8_t  `data[8]` = [..]
  >
  > ```c++
  > struct {
  >     bool on;                    // Вкл/выкл Bose
  >     bool audio_plt;             // Audio PLT
  >     bool radio_fm;              // Radio FM или AM
  >     bool wow;                   // Wow
  >     bool press;                 // Нажатие кнопки (для звука Wow)
  >     bool mute;                  // Выкл. звук
  >     bool start;                 // Изменять уровень звука при включении адаптера
  >     uint8_t volume;             // Уровень звука (от 0 до 63)
  >     uint8_t start_volume;       // Уровень звука при включении адаптера (от 0 до 63)
  >     int8_t balance;             // Баланс (от -8 до +8)
  >     int8_t bass;                // Бас (от -6 до +6)
  >     int8_t fade;                // Fade (от -8 до +8)
  >     int8_t treble;              // Treble (от -6 до +6)
  >     uint8_t center_point;       // Center point
  > }
  > ```

  `center_point`:

  >`0x00` off
  >
  >`0x01` min
  >
  >`0x02` low
  >
  >`0x03` mid
  >
  >`0x04` hi
  >
  >`0x05` max

* **Конфигурация отображения значений Bose:**

  **запрос:**
  > uint8_t `id` = `0x63`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0x63`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Климат-контроль

* **Значения климат-контроля:**

  **запрос:**
  > uint8_t `id` = `0x71`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x71`
  >
  > uint16_t `size` = `0x05`
  >
  > uint8_t  `data[5]` = [..]
  >
  > ```c++
  > struct {
  >     bool on;                        // Вкл/выкл. блока LCD климата
  >     bool automode;                  // Автоматический режим работы блока климата
  >     bool ac;                        // Статус работы кондиционера
  >     bool eco;                       // Режим eco
  >     bool air_dlegs;                 // Направление воздушного потока в ноги
  >     bool air_dbody;                 // Направление воздушного потока в туловище
  >     bool air_dwindshield;           // Направление воздушного потока в ветровое стекло
  >     bool dback_win;                 // Подогрев заднего стекла
  >     bool air_inside;                // Забор воздуха из салона
  >     bool air_outside;               // Забор воздуха снаружи
  >     bool temperature_settable;      // Режим установки температуры
  >     bool temperature_amb;           // Режим отображения температуры за бортом или текущая
  >     bool temperature_celsius;       // Показать значения температуры в Цельсиях
  >     bool temperature_fahrenheit;    // Показать значения температуры в Фаренгейтах
  >     uint8_t air_rate;               // Скорость воздушного потока (от минимального 1 до максимального 7)
  >     uint16_t temperature;           // Температура (n/10)
  > }
  > ```

* **Конфигурация отображения значений климат-контроля:**

  **запрос:**
  > uint8_t `id` = `0x73`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0x73`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Двери

* **Параметры дверей:**

  **запрос:**
  > uint8_t `id` = `0x80`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > ```c++
  > struct {
  >     bool front_reverse;         // Поменять местами передние двери
  >     bool back_reverse;          // Поменять местами задние двери
  >     bool front_back_reverse;    // Поменять местами передние с задними дверьми
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x80`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > ```c++
  > struct {
  >     bool front_reverse;         // Поменять местами передние двери
  >     bool back_reverse;          // Поменять местами задние двери
  >     bool front_back_reverse;    // Поменять местами передние с задними дверьми
  > }
  > ```

* **Значения дверей:**

  **запрос:**
  > uint8_t `id` = `0x81`
  >
  > uint16_t `size` = `0x00`

  **ответ:**

  > uint8_t `id` = `0x81`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > ```c++
  > struct {
  >     bool front_left;        // Передняя левая дверь
  >     bool front_right;       // Передняя правая дверь
  >     bool back_left;         // Задняя левая дверь
  >     bool back_right;        // Задняя правая дверь
  >     bool trunk;             // Багажник
  >     bool bonnet;            // Капот
  > }
  > ```

* **Конфигурация отображения значений дверей:**

  **запрос:**
  > uint8_t `id` = `0x83`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0x83`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Двигатель внутреннего сгорания (ДВС)

* **Параметры ДВС:**

  **запрос:**
  > uint8_t `id` = `0x90`
  >
  > uint16_t `size` = `0x11`
  >
  > uint8_t  `data[17]` = [..]
  >
  > ```c++
  > struct {
  >     bool show_days;             // Показывать дни в моточасах
  >     uint64_t total_worktime;    // Счетчик моточасов, сек.
  >     uint64_t total_count_rpm;   // Счетчик коленчатого вала (RPM), об.
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x90`
  >
  > uint16_t `size` = `0x11`
  >
  > uint8_t  `data[17]` = [..]
  >
  > ```c++
  > struct {
  >     bool show_days;             // Показывать дни в моточасах
  >     uint64_t total_worktime;    // Счетчик моточасов, сек.
  >     uint64_t total_count_rpm;   // Счетчик коленчатого вала (RPM), об.
  > }
  > ```

* **Значения ДВС:**

  **запрос:**
  > uint8_t `id` = `0x91`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x91`
  >
  > uint16_t `size` = `0x19`
  >
  > uint8_t  `data[25]` = [..]
  >
  > ```c++
  > struct {
  >     bool on;                    // Статус работы двигателя
  >     int8_t coolant;             // Температура охлаждающей жидкости
  >     uint16_t rpm;               // Количество оборотов коленчатого вала (RPM)
  >     uint32_t worktime;          // Время работы двигателя с момента его запуска, сек.
  >     uint32_t count_rpm;         // Счетчик RPM с момента запуска двигателя, об.
  >     uint16_t load;              // Нагрузка на ДВС, % (n/1000)
  >     uint16_t throttle;          // Положение дроссельной заслонки, % (n/100)
  >     uint16_t view_days;         // Счетчик моточасов, дней
  >     uint8_t view_hours;         // Счетчик моточасов, часов
  >     uint8_t view_minutes;       // Счетчик моточасов, минут
  >     uint8_t view_seconds;       // Счетчик моточасов, секунд
  >     uint32_t view_count_rpm;    // Счетчик коленчатого вала (RPM), тыс.об.
  > }
  > ```

* **Действие с параметрами ДВС:**

  **запрос:**
  > uint8_t `id` = `0x92`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > ```c++
  > struct {
  >     bool reset_worktime;        // Сбросить счетчик моточасов
  >     bool reset_count_rpm;       // Сбросить счетчик коленчатого вала (RPM)
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0x92`
  >
  > uint16_t `size` = `0x00`

* **Параметры отображения значений ДВС:**

  **запрос:**
  > uint8_t `id` = `0x93`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0x93`
  >
  > uint16_t `size` = `0x1c`
  >
  > uint8_t  `data[28]` = [..]
  >
  > ```c++
  > struct {
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } enabled,              // Отображение запуска/остановки ДВС
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } total_worktime,       // Отображение моточасов ДВС
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } total_count_rpm,      // Отображение счетчика оборотов коленчатого вала ДВС
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } coolant,              // Отображение температуры охлаждающей жидкости ДВС
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } rpm,                  // Отображение оборотов коленчатого вала ДВС
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } load,                 // Отображение нагрузки на ДВС
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } throttle              // Отображение положения дросселя
  > }
  > ```

* **Конфигурация отображения запуска/остановки ДВС:**

  **запрос:**
  > uint8_t `id` = `0x94`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0x94`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения моточасов ДВС:**

  **запрос:**
  > uint8_t `id` = `0x95`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0x95`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения счетчика оборотов коленчатого вала ДВС:**

  **запрос:**
  > uint8_t `id` = `0x96`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0x96`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения температуры охлаждающей жидкости ДВС:**

  **запрос:**
  > uint8_t `id` = `0x97`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0x97`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения оборотов коленчатого вала ДВС:**

  **запрос:**
  > uint8_t `id` = `0x98`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0x98`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения нагрузки на ДВС:**

  **запрос:**
  > uint8_t `id` = `0x99`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0x99`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения положения дросселя:**

  **запрос:**
  > uint8_t `id` = `0x9a`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0x9a`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Расход топлива

* **Параметры расхода:**

  **запрос:**
  > uint8_t `id` = `0xa0`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     uint16_t ratio;         // Коэффициент (n/1000) 0.001 до 1
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0xa0`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     uint16_t ratio;         // Коэффициент (n/1000) 0.001 до 1
  > }
  > ```

* **Значения расхода:**

  **запрос:**
  > uint8_t `id` = `0xa1`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0xa1`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > ```c++
  > struct {
  >     uint16_t current;       // Текущий расход топлива, л/100 км (n/10)
  >     uint16_t avg;           // Средний расход топлива, л/100 км (n/10)
  > }
  > ```

* **Параметры отображения значений расхода:**

  **запрос:**
  > uint8_t `id` = `0xa3`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0xa3`
  >
  > uint16_t `size` = `0x08`
  >
  > uint8_t  `data[8]` = [..]
  >
  > ```c++
  > struct {
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } current,              // Отображение текущего расхода топлива
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } avg                   // Отображение среднего расхода топлива
  > }
  > ```

* **Конфигурация отображения текущего расхода топлива:**

  **запрос:**
  > uint8_t `id` = `0xa4`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xa4`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения среднего расхода топлива:**

  **запрос:**
  > uint8_t `id` = `0xa5`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xa5`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Движение автомобиля

* **Значения движения:**

  **запрос:**
  > uint8_t `id` = `0xb1`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0xb1`
  >
  > uint16_t `size` = `0x0a`
  >
  > uint8_t  `data[10]` = [..]
  >
  > ```c++
  > struct {
  >     uint32_t speed;         // Скорость автомобиля, км/ч (n/100)
  >     uint16_t speed_avg;     // Средняя скорость, км/ч
  >     uint32_t rest_way;      // Остаток пути, км (n/100)
  > }
  > ```

* **Параметры отображения значений движения:**

  **запрос:**
  > uint8_t `id` = `0xb3`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0xb3`
  >
  > uint16_t `size` = `0x0c`
  >
  > uint8_t  `data[12]` = [..]
  >
  > ```c++
  > struct {
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } speed,                // Отображение скорости автомобиля
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } speed_avg,            // Отображение средней скорости автомобиля
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } rest_way              // Отображение остатка пути автомобиля
  > }
  > ```

* **Конфигурация отображения скорости автомобиля:**

  **запрос:**
  > uint8_t `id` = `0xb4`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xb4`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения средней скорости автомобиля:**

  **запрос:**
  > uint8_t `id` = `0xb5`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xb5`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения остатка пути автомобиля:**

  **запрос:**
  > uint8_t `id` = `0xb6`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xb6`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Датчики

* **Значения датчиков:**

  **запрос:**
  > uint8_t `id` = `0xc1`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0xc1`
  >
  > uint16_t `size` = `0x01`
  >
  > uint8_t  `data[1]` = [..]
  >
  > ```c++
  > struct {
  >     bool acc;                   // Сигнал АСС
  >     bool handbrake;             // Ручной тормоз
  >     bool reverse;               // Задний ход автомобиля
  >     bool seatbelt_driver;       // Ремень безопасности водителя
  >     bool seatbelt_passenger;    // Ремень безопасности пассажира
  >     bool turn_signal_left;      // Сигнал левого поворота
  >     bool turn_signal_right;     // Сигнал правого поворота
  >     bool high_beam;             // Дальний свет фар
  > }
  > ```

* **Параметры отображения значений датчиков:**

  **запрос:**
  > uint8_t `id` = `0xc3`
  >
  > uint16_t `size` = `0x00`

  **ответ:**
  > uint8_t `id` = `0xc3`
  >
  > uint16_t `size` = `0x10`
  >
  > uint8_t  `data[16]` = [..]
  >
  > ```c++
  > struct {
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } handbrake,            // Отображение статуса ручника
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } reverse,              // Отображение заднего хода автомобиля
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } seatbelt,             // Отображение остатка пути автомобиля
  >     struct {
  >         bool enabled;            // Вкл/выкл отображения
  >         uint8_t type;            // Тип отображения текста
  >         uint8_t time;            // Время отображения на LCD, сек.
  >         uint8_t delay;           // Время паузы отображения на LCD, сек.
  >     } turn_signal           // Отображение непристегнутых ремней безопасности
  > }
  > ```

* **Конфигурация отображения ручного тормоза:**

  **запрос:**
  > uint8_t `id` = `0xc4`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xc4`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения заднего хода автомобиля:**

  **запрос:**
  > uint8_t `id` = `0xc5`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xc5`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения непристегнутых ремней безопасности:**

  **запрос:**
  > uint8_t `id` = `0xc6`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**
  > uint8_t `id` = `0xc6`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

* **Конфигурация отображения сигналов поворота:**

  **запрос:**
  > uint8_t `id` = `0xc7`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0xc7`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Температура

* **Значения температуры:**

  **запрос:**
  > uint8_t `id` = `0xd1`
  >
  > uint16_t `size` = `0x00`

  **ответ:**

  > uint8_t `id` = `0xd1`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > ```c++
  > struct {
  >     int16_t in;     // Температура в салоне (n/10)
  >     int16_t out;    // Температура окружающего среды (n/10)
  > }
  > ```

* **Конфигурация отображения значений температуры:**

  **запрос:**
  > uint8_t `id` = `0xd3`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0xd3`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Звук

* **Значение уровня звука ГУ:**

  **запрос:**
  > uint8_t `id` = `0xe1`
  >
  > uint16_t `size` = `0x00`

  **ответ:**

  > uint8_t `id` = `0xe1`
  >
  > uint16_t `size` = `0x02`
  >
  > uint8_t  `data[2]` = [..]
  >
  > ```c++
  > struct {
  >     bool mute;              // Выкл. звук
  >     uint8_t volume;         // Уровень звука
  > }
  > ```

* **Конфигурация отображения уровня звука:**

  **запрос:**
  > uint8_t `id` = `0xe3`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0xe3`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Тест

* **Тест отображения:**

  **запрос:**
  > uint8_t `id` = `0xf0`
  >
  > uint16_t `size` = `0x20`
  >
  > uint8_t  `data[32]` = [..]
  >
  > ```c++
  > struct {
  >     char text[32];          // Текст
  > }
  > ```

  **ответ:**
  > uint8_t `id` = `0xf0`
  >
  > uint16_t `size` = `0x00`

* **Конфигурация отображения тестового сообщения:**

  **запрос:**
  > uint8_t `id` = `0xf3`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*

  **ответ:**

  > uint8_t `id` = `0xf3`
  >
  > uint16_t `size` = `0x04`
  >
  > uint8_t  `data[4]` = [..]
  >
  > *см. Конфигурация отображения*



#### Конфигурация отображения


**Структура**

> ```c++
> struct {
>     bool enabled;           // Вкл/выкл отображения
>     uint8_t type;           // Тип отображения текста
>     uint8_t time;           // Время отображения на LCD, сек.
>     uint8_t delay;          // Время паузы отображения на LCD, сек.
> }
> ```

`type`:
> `0x00` Простое отображение текста
>
> `0x01` Мигающий текст
>
> `0x02` Бегущая строка



#### Выборочный запрос данных

**запрос:**
> uint8_t `id` = `0x10`
>
> uint16_t `size` = от `0x01` до `0x1fd`
>
> uint8_t  `data[2..509]` = [..]
>
> ```c++
> struct {
>     uint8_t repeat;         // Повтор с интервалом repeat * 250. repeat === 0 - выкл. 
>     uint8_t id[..];         // Массив ID
> }
>    ```
>

**ответ:**

> uint8_t `id` = `0x10`
>
> uint16_t `size` = от `0x00` до `0x1fd`
>
> uint8_t  `data[0..509]` = [..]
>
> ```c++
> struct {
>     struct {
>         uint8_t id;         // ID пакета
>         uint16_t size;      // Размер данных
>         uint8_t data[size]; // Данные
>     } package[..];      // Массив пакетов данных
> }
>    ```
